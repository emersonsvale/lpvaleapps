-- Estrutura de blog para SEO e CMS
-- Data: 2026-02-27

create table if not exists public.blog_posts (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  slug text not null unique,
  title text not null,
  excerpt text not null,
  content_markdown text,
  content_html text not null,
  status text not null default 'draft' check (status in ('draft', 'scheduled', 'published')),
  published_at timestamptz,
  scheduled_at timestamptz,
  author_name text not null default 'Vale Apps',
  cover_image text,
  cover_alt text,
  reading_time int,
  canonical_url text,
  seo_title text,
  seo_description text,
  focus_keyword text,
  og_image text,
  noindex boolean not null default false
);

create table if not exists public.blog_categories (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  slug text not null unique,
  name text not null,
  description text
);

create table if not exists public.blog_tags (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  slug text not null unique,
  name text not null
);

create table if not exists public.blog_post_categories (
  post_id bigint not null references public.blog_posts(id) on delete cascade,
  category_id bigint not null references public.blog_categories(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (post_id, category_id)
);

create table if not exists public.blog_post_tags (
  post_id bigint not null references public.blog_posts(id) on delete cascade,
  tag_id bigint not null references public.blog_tags(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (post_id, tag_id)
);

create index if not exists idx_blog_posts_status_published_at on public.blog_posts(status, published_at desc);
create index if not exists idx_blog_posts_updated_at on public.blog_posts(updated_at desc);
create index if not exists idx_blog_posts_slug on public.blog_posts(slug);
create index if not exists idx_blog_categories_slug on public.blog_categories(slug);
create index if not exists idx_blog_tags_slug on public.blog_tags(slug);
create index if not exists idx_blog_post_categories_post on public.blog_post_categories(post_id);
create index if not exists idx_blog_post_categories_category on public.blog_post_categories(category_id);
create index if not exists idx_blog_post_tags_post on public.blog_post_tags(post_id);
create index if not exists idx_blog_post_tags_tag on public.blog_post_tags(tag_id);

create or replace function public.set_updated_at_timestamp()
returns trigger as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

drop trigger if exists trg_blog_posts_updated_at on public.blog_posts;
create trigger trg_blog_posts_updated_at
before update on public.blog_posts
for each row execute function public.set_updated_at_timestamp();

drop trigger if exists trg_blog_categories_updated_at on public.blog_categories;
create trigger trg_blog_categories_updated_at
before update on public.blog_categories
for each row execute function public.set_updated_at_timestamp();

drop trigger if exists trg_blog_tags_updated_at on public.blog_tags;
create trigger trg_blog_tags_updated_at
before update on public.blog_tags
for each row execute function public.set_updated_at_timestamp();

alter table public.blog_posts enable row level security;
alter table public.blog_categories enable row level security;
alter table public.blog_tags enable row level security;
alter table public.blog_post_categories enable row level security;
alter table public.blog_post_tags enable row level security;

-- leitura pública apenas para posts efetivamente publicados
drop policy if exists "Public can read published blog posts" on public.blog_posts;
create policy "Public can read published blog posts"
on public.blog_posts for select
to anon, authenticated
using (
  status = 'published'
  and coalesce(noindex, false) = false
  and (published_at is null or published_at <= now())
);

-- usuário autenticado (admin) pode gerenciar posts
drop policy if exists "Authenticated can manage blog posts" on public.blog_posts;
create policy "Authenticated can manage blog posts"
on public.blog_posts for all
to authenticated
using (true)
with check (true);

drop policy if exists "Public can read blog categories" on public.blog_categories;
create policy "Public can read blog categories"
on public.blog_categories for select
to anon, authenticated
using (true);

drop policy if exists "Authenticated can manage blog categories" on public.blog_categories;
create policy "Authenticated can manage blog categories"
on public.blog_categories for all
to authenticated
using (true)
with check (true);

drop policy if exists "Public can read blog tags" on public.blog_tags;
create policy "Public can read blog tags"
on public.blog_tags for select
to anon, authenticated
using (true);

drop policy if exists "Authenticated can manage blog tags" on public.blog_tags;
create policy "Authenticated can manage blog tags"
on public.blog_tags for all
to authenticated
using (true)
with check (true);

drop policy if exists "Public can read blog post categories" on public.blog_post_categories;
create policy "Public can read blog post categories"
on public.blog_post_categories for select
to anon, authenticated
using (true);

drop policy if exists "Authenticated can manage blog post categories" on public.blog_post_categories;
create policy "Authenticated can manage blog post categories"
on public.blog_post_categories for all
to authenticated
using (true)
with check (true);

drop policy if exists "Public can read blog post tags" on public.blog_post_tags;
create policy "Public can read blog post tags"
on public.blog_post_tags for select
to anon, authenticated
using (true);

drop policy if exists "Authenticated can manage blog post tags" on public.blog_post_tags;
create policy "Authenticated can manage blog post tags"
on public.blog_post_tags for all
to authenticated
using (true)
with check (true);

grant select on public.blog_posts to anon;
grant select on public.blog_categories, public.blog_tags, public.blog_post_categories, public.blog_post_tags to anon;
grant all on public.blog_posts, public.blog_categories, public.blog_tags, public.blog_post_categories, public.blog_post_tags to authenticated;
